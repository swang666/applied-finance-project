"""Contains the base class for defining a data pipeline
"""
from abc import ABC, abstractmethod

class Pipeline(ABC):
    """A base class for creating custom data pipelines by chaining coroutines
    """

    def __init__(self, pipelines=None, input_stream=None):
        """Initialises the pipeline

        Args:
            pipelines (:obj:`list` of :obj:`Pipeline`): Downstream pipelines to
                run with the processed data. Defaults to None
            input_stream: An iterable containing data to be processed by the
                pipeline. Defaults to None
        """
        self._pipelines = pipelines if pipelines is not None else []
        self._input_stream = input_stream
        self._result = None

    @abstractmethod
    async def coroutine(self, data):
        """Processes the data and returns the result

        Args:
            data: The data to be processed by the pipeline
        """

    async def run(self, data):
        """Runs the corutine and calls the downstream pipelines after setting
        self._result to the coroutine's return value.

        Args:
            data: The data to be processed by the pipeline
        """
        self._result = await self.coroutine(data)
        for pipeline in self._pipelines:
            await pipeline.run(self._result)

    async def output_stream(self):
        """Processes the data as a stream. The `result` property will change to
        reflect the most recently processed element of the input data stream.

        Yields:
            The result of running the coroutine function on a single element of
            the input data stream
        """
        if self._input_stream is None:
            raise Exception("No input data stream has been set")
        try: # try a normal for loop
            for data in self._input_stream:
                self._result = await self.coroutine(data)
                yield self.result
        except TypeError as error:
            # If the input stream is async use an async for loop instead
            if str(error) == "'async_generator' object is not iterable":
                async for data in self._input_stream:
                    self._result = await self.coroutine(data)
                    yield self.result
            else:
                raise error

    @property
    def result(self):
        """The result generated by the coroutine or None if the pipeline has not
        run yet
        """
        return self._result
